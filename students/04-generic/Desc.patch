--- ../04-generic/Desc.lagda.rst	2019-01-25 10:19:46.702610190 +0100
+++ 04-generic/Desc.lagda.rst.orig	2019-02-22 10:16:23.013261413 +0100
@@ -23,19 +23,6 @@
   - Traversable
   - Want more? `Typeclassopedia`_!
 
-.. BEGIN HIDE
-  missing:
-   - Monad transformers,
-   - MonadFix,
-   - Semigroup,
-   - Alternative,
-   - MonadPlus,
-   - Category,
-   - Arrow,
-   - Comonad
-
-.. TODO: resurrect Xavier's applicative examples?
-.. END HIDE
 
 Intensional side of this lecture:
   - reflecting inductive types
@@ -194,8 +181,7 @@
 exactly what ``map`` does::
 
     map-Vec : ∀ {n}{A B : Set} → (A → B) → vec n A → vec n B
-    map-Vec f [] = []
-    map-Vec f (x ∷ xs) = f x ∷ map-Vec f xs
+    map-Vec f xs = {!!}
 
 This would allow us to lift the operation ``square`` on numbers to
 apply on vectors of numbers.
@@ -254,13 +240,6 @@
 
 **Exercise (difficulty: 1)** Show that lists define a functor.
 
-.. BEGIN HIDE
-  ::
-    instance
-      ListFunctor : Functor List
-      _<$>_ {{ListFunctor}} f [] = []
-      _<$>_ {{ListFunctor}} f (x ∷ xs) = f x ∷ (f <$> xs)
-.. END HIDE
 
 **Exercise (difficulty: 1)** We define::
 
@@ -271,11 +250,6 @@
 
 Let ``A : Set``. Is ``Arrow A : Set → Set`` an endofunctor on ``Set``?
 
-.. BEGIN HIDE
-  ::
-    ArrowFunctor : ∀ {A} → Functor (Arrow A)
-    _<$>_ {{ArrowFunctor}} f (ar g) = ar (f ∘ g)
-.. END HIDE
 
 
 **Exercise (difficulty: 1)** We define::
@@ -290,18 +264,6 @@
 
 **Exercise (difficulty: 3)** Constructively prove your above answer.
 
-.. BEGIN HIDE
-  ::
-    open import Data.Empty
-
-    pf-CoArrow-not-Functor : Functor (CoArrow ⊥) → ⊥
-    pf-CoArrow-not-Functor F = CoArrow.apply (f <$>F x) tt
-        where open Functor F renaming (_<$>_ to _<$>F_)
-              f : ⊥ → ⊤
-              f _ = tt
-              x : CoArrow ⊥ ⊥
-              x = co λ falso → falso
-.. END HIDE
 
 --------------------------------
 Applicative
@@ -312,23 +274,20 @@
 
     zipWith-Vec : ∀ {n} {A B C : Set} →
               (A → B → C) → vec n A → vec n B → vec n C
-    zipWith-Vec f [] [] = []
-    zipWith-Vec f (x ∷ xs) (y ∷ ys) = f x y ∷ zipWith-Vec f xs ys
+    zipWith-Vec f xs ys = {!!}
 
 However, ``zipWith`` can be obtained from two more primitive
 operations and the functoriality of vectors::
 
     replicate-Vec : ∀ {n} {A : Set} → A → vec n A
-    replicate-Vec {n = zero}  x = []
-    replicate-Vec {n = suc n} x = x ∷ replicate-Vec x
+    replicate-Vec {n = n} x = {!!}
 
     _<*>-Vec_ : ∀ {n} {A B : Set} → vec n (A → B) → vec n A → vec n B
-    []       <*>-Vec []       = []
-    (f ∷ fs) <*>-Vec (x ∷ xs) = f x ∷ (fs <*>-Vec xs)
+    fs <*>-Vec xs = {!!}
 
     zipWith-Vec' : ∀ {n} {A B C : Set} →
               (A → B → C) → vec n A → vec n B → vec n C
-    zipWith-Vec' f xs ys = f <$> xs <*>-Vec ys
+    zipWith-Vec' f xs ys = {!!}
 
 A functor equipped with these two operations is an `applicative
 functor <https://wiki.haskell.org/Typeclassopedia#Applicative>`_::
@@ -343,7 +302,7 @@
         overlap {{super}} : Functor F
 
       zipWith : ∀ {A B C} → (A → B → C) → F A → F B → F C
-      zipWith f x y = f <$> x ⊛ y
+      zipWith f x y = {!!}
 
       _<⊛_ : ∀ {A B} → F A → F B → F A
       a <⊛ b = const <$> a ⊛ b
@@ -414,17 +373,12 @@
 
     instance
       StateFunctor : ∀ {A : Set} → Functor (State A)
-      _<$>_ {{StateFunctor}} f m s = let (x , s') = m s in
-                                     f x , s'
+      _<$>_ {{StateFunctor}} f m s = {!!}
+
       StateApplicative : ∀ {A : Set} → Applicative (State A)
-      pure {{StateApplicative}} x s = x , s
-      _⊛_  {{StateApplicative}} fs xs s = let (f , s') = fs s in
-                                          let (x , s'') = xs s' in
-                                          f x , s''
-
-.. BEGIN HIDE
-.. TODO: write the instances above (<$>, pure and ⊛) using the monadic operations
-.. END HIDE
+      pure {{StateApplicative}} x s = {!!}
+      _⊛_  {{StateApplicative}} fs xs s = {!!}
+
 
 **Exercise (difficulty: 1)** Write a program that takes a monad (specified with ``return`` and ``>>=``) and produces its underlying applicative.
 
@@ -438,18 +392,6 @@
 
 Let ``A : Set``. Is ``PPair A : Set → Set`` an endofunctor on ``Set``? Is it an applicative?
 
-.. BEGIN HIDE
-  ::
-
-    PPairFunctor : ∀ {A} → Functor (PPair A)
-    _<$>_ {{PPairFunctor}} f ⟨ x , y ⟩ = ⟨ x , f y ⟩
-
-    pf-PPair-not-Applicative : Applicative (PPair ⊥) → ⊥
-    pf-PPair-not-Applicative A = PPair.fst x
-      where open Applicative A renaming (pure to pure-A)
-            x : PPair ⊥ ⊤
-            x = pure-A tt
-.. END HIDE
 
 **Exercise (difficulty: 2)** We define::
 
@@ -465,9 +407,6 @@
 enabling us to parse context-free grammars (ie. regular
 expressions). Is it (necessarily) a monad?
 
-.. BEGIN HIDE
-.. TODO Provide solution
-.. END HIDE
 
 
 --------------------------------
@@ -497,17 +436,13 @@
 while the second corresponds to a tabulation::
 
     lookup-Vec : ∀ {n} {A : Set} → vec n A → Fin n → A
-    lookup-Vec (x ∷ xs)  zero = x
-    lookup-Vec (x ∷ xs) (suc i) = lookup-Vec xs i
+    lookup-Vec xs k = {!!}
 
     tabulate-Vec : ∀ {n} {A : Set} → (Fin n → A) → vec n A
-    tabulate-Vec {zero}  f = []
-    tabulate-Vec {suc n} f = f zero ∷ tabulate-Vec (f ∘ suc)
+    tabulate-Vec {n}  f = {!!}
 
     transpose-Matrix : ∀ {m n} {A : Set} → matrix m n A → matrix n m A
-    transpose-Matrix m = tabulate-Vec (λ i →
-                         tabulate-Vec (λ j →
-                         lookup-Vec (lookup-Vec m j) i))
+    transpose-Matrix m = {!!}
 
 ..
   ::
@@ -533,7 +468,7 @@
         overlap {{super}} : Functor F
 
       positions : F Log
-      positions = tabulate λ ix → ix
+      positions = {!!}
 
     open Naperian {{...}}
 
@@ -549,82 +484,16 @@
 **Exercise (difficulty: 2)** State the Naperian laws and prove them
 for vectors.
 
-.. BEGIN HIDE
-  ::
-    record IsNaperian (F : Set → Set){{F-Naperian : Naperian F}} : Set₁ where
-      field
-        tabulate-lookup : ∀ {A} (v : F A) →
-                            tabulate (lookup v)  ≡ v
-        lookup-tabulate : ∀ {A} (f : Log {{F-Naperian}} → A)(l : Log {{F-Naperian}}) →
-                            lookup {{F-Naperian}} (tabulate f) l  ≡ f l
-
-    VectorIsNaperian : ∀{n} → IsNaperian (vec n)
-    VectorIsNaperian = record { tabulate-lookup = tabulate-lookup
-                              ; lookup-tabulate = lookup-tabulate }
-      where tabulate-lookup : ∀ {n A} (v : vec n A) →
-                            tabulate (lookup v)  ≡ v
-            tabulate-lookup [] = refl
-            tabulate-lookup (x ∷ v) rewrite tabulate-lookup v = refl
-
-            lookup-tabulate : ∀ {n A} (f : Fin n → A)(l : Fin n) →
-                            lookup {{VecNaperian}} (tabulate f) l  ≡ f l
-            lookup-tabulate f zero = refl
-            lookup-tabulate f (suc l) rewrite lookup-tabulate (λ n → f (suc n)) l = refl
-.. END HIDE
 
 **Exercise (difficulty: 1)** Show that a Naperian functor is
 necessarily an Applicative functor.
 
-.. BEGIN HIDE
-  ::
-    Naperian→Applicative :  (F : Set → Set){{_ : Naperian F}} → Applicative F
-    pure {{Naperian→Applicative F}} a = tabulate (λ _ → a)
-    _⊛_ {{Naperian→Applicative F}} f a = tabulate (λ ix → (lookup f ix) (lookup a ix))
-.. END HIDE
 
 **Exercise (difficulty: 2)** Show that Naperian functors deserve their
 name: for ``f`` and ``g`` two Naperian functors, define ``Log (f ×
 g)`` and ``Log (f ∘ g)`` in terms of ``Log f`` and ``Log g``. Any
 other remarkable identities?
 
-.. BEGIN HIDE
-  ::
-
-    record Prod (F : Set → Set)(G : Set → Set)(X : Set) : Set where
-      constructor ⟨_,_⟩
-      field
-        fst : F X
-        snd : G X
-
-    ProdFunctor : (F : Set → Set)(G : Set → Set){{_ : Functor F}}{{_ : Functor G}} →
-                    Functor (Prod F G)
-    _<$>_ {{ProdFunctor F G}} f ⟨ x , y ⟩ = ⟨ f <$> x , f <$> y ⟩
-
-    ProdNaperian : (F : Set → Set)(G : Set → Set)
-                    {{_ : Naperian F}}{{_ : Naperian G}} →
-                    Naperian (Prod F G)
-    Log {{ProdNaperian F G {{F-Naperian}} {{G-Naperian}}}} = Log {{F-Naperian}} ⊎ Log {{G-Naperian}}
-    lookup {{ProdNaperian F G}} ⟨ x , y ⟩ ( inj₁ ix) = lookup x ix
-    lookup {{ProdNaperian F G}} ⟨ x , y ⟩ ( inj₂ jx) = lookup y jx
-    tabulate {{ProdNaperian F G}} f = ⟨ tabulate (λ x → f (inj₁ x)) , tabulate (λ x → f (inj₂ x)) ⟩
-    super {{ProdNaperian F G}} = ProdFunctor F G
-
-    data Comp(F : Set → Set) (G : Set → Set)(X : Set) : Set where
-      C : F (G X) → Comp F G X
-
-    CompFunctor : (F : Set → Set)(G : Set → Set){{_ : Functor F}}{{_ : Functor G}} →
-                    Functor (Comp F G)
-    _<$>_ {{CompFunctor F G {{F-Functor}}{{G-Functor}}}} f (C x) = C ((_<$>_ f) <$> x)
-
-    CompNaperian : (F : Set → Set)(G : Set → Set)
-                    {{_ : Naperian F}}{{_ : Naperian G}} →
-                    Naperian (Comp F G)
-    Log {{CompNaperian F G {{F-Naperian}} {{G-Naperian}}}} = Log {{F-Naperian}} × Log {{G-Naperian}}
-    lookup {{CompNaperian F G}} (C x) (ix , jx) = lookup (lookup x ix) jx
-    tabulate {{CompNaperian F G}} f = C (tabulate (λ ix → tabulate (λ jx → f (ix , jx))))
-    super {{CompNaperian F G}} = CompFunctor F G
-
-.. END HIDE
 
 Pairs are Naperian too::
 
@@ -637,13 +506,6 @@
 
 **Exercise (difficulty: 1)** Give an example of a Functor that is **not** Naperian.
 
-.. BEGIN HIDE
-
-  Any structure that cannot be statically indexed (in a total manner)
-  will do the trick. For example, lists or any kind of data-structure
-  whose size is unknown at compile-time.
-
-.. END HIDE
 
 
 Given any pair of Naperian functors, transposition is expressed as
@@ -652,7 +514,7 @@
     transpose : ∀ {F G : Set → Set}
                   {{_ : Naperian F}}{{_ : Naperian G}} →
                 ∀ {A} → F (G A) → G (F A)
-    transpose fga = tabulate <$> (tabulate (λ gx fx → lookup (lookup fga fx) gx))
+    transpose fga = {!!}
 
 ..
   ::
@@ -698,11 +560,6 @@
         id-right : (a : A) → mempty <> a ≡ a
         assoc : (a b c : A) → (a <> b) <> c ≡ a <> (b <> c)
 
-.. BEGIN HIDE
-.. TODO: activate?
-.. {-# DISPLAY Monoid.mempty _ = mempty #-}
-.. {-# DISPLAY Monoid._<>_ _ a b = a <> b #-}
-.. END HIDE
 
 Famous monoids include ``(ℕ, 0, _+_)`` and ``(List A, [], _++_)``
 (also called the free monoid)::
@@ -737,8 +594,7 @@
 a given monoid::
 
     foldMap-Vec : ∀ {n}{A}{W : Set} {{MonW : Monoid W}} → (A → W) → vec n A → W
-    foldMap-Vec f [] = mempty
-    foldMap-Vec f (x ∷ xs) = f x <> foldMap-Vec f xs
+    foldMap-Vec f xs = {!!}
 
     sumAll-Vec : ∀ {n} → vec n ℕ → ℕ
     sumAll-Vec = foldMap-Vec id
@@ -747,13 +603,13 @@
 by exploiting the fact that endomorphisms form a monoid::
 
     foldr-Vec : ∀ {n}{A B : Set} → (A → B → B) → B → vec n A → B
-    foldr-Vec su ze fs = foldMap-Vec su fs ze
+    foldr-Vec su ze fs = {!!}
 
 Conversely, we can interpret it into the initial model of foldability,
 namely lists::
 
     toList-Vec : ∀ {n A} → vec n A → List A
-    toList-Vec = foldMap-Vec (λ a → a ∷ [])
+    toList-Vec = {!!}
 
 ..
   ::
@@ -779,20 +635,17 @@
       foldr su ze fs = foldMap su fs ze
 
       toList : ∀ {A} → F A → List A
-      toList = foldMap (λ a → a ∷ [])
+      toList = {!!}
 
     open Foldable {{...}}
 
     sumAll : ∀ {F} → {{ _ : Foldable F}} → F ℕ → ℕ
-    sumAll = foldMap id
+    sumAll = {!!}
 
     instance
       VecFoldable : ∀ {n} → Foldable (λ A → Vec A n)
       foldMap {{VecFoldable}} = foldMap-Vec
 
-.. BEGIN HIDE
-.. TODO add equational theory
-.. END HIDE
 
 Pairs are foldable too::
 
@@ -802,13 +655,6 @@
 
 **Exercise (difficulty: 1)** Show that lists are foldable.
 
-.. BEGIN HIDE
-  ::
-    instance
-      ListFoldable : Foldable List
-      foldMap {{ListFoldable}} f [] = mempty
-      foldMap {{ListFoldable}} f (x ∷ xs) = f x <> foldMap f xs
-.. END HIDE
 
 ..
   ::
@@ -832,14 +678,13 @@
 iteration::
 
     traverse-Vec : ∀ {n F A B} {{_ : Applicative F}} → (A → F B) → vec n A → F (vec n B)
-    traverse-Vec f [] = pure []
-    traverse-Vec f (x ∷ v) = _∷_ <$> f x ⊛ traverse-Vec f v
+    traverse-Vec f xs = {!!}
 
     increase : ℕ → State ℕ ℕ
     increase n = λ m → let n' = m + n in n' , n'
 
     sumsAll-Vec : ∀ {n} → vec n ℕ → vec n ℕ
-    sumsAll-Vec xs = proj₁ (traverse-Vec increase xs 0)
+    sumsAll-Vec xs = {!!}
 
 ..
   ::
@@ -867,7 +712,7 @@
         overlap {{super}} : Foldable T
 
       sequence :  ∀ {F : Set → Set} {A} {{_ : Applicative F}} → T (F A) -> F (T A)
-      sequence = traverse id
+      sequence = {!!}
 
     open Traversable ⦃...⦄
     instance
@@ -875,9 +720,6 @@
       traverse {{VectorTraversable}} f [] = pure []
       traverse {{VectorTraversable}} f (x ∷ v) = _∷_ <$> f x ⊛ traverse f v
 
-.. BEGIN HIDE
-.. TODO add equational theory
-.. END HIDE
 
 Surprise, pairs are traversable too::
 
@@ -921,7 +763,7 @@
 
 
       size : ∀ {α} → F α → ℕ
-      size as = length (toList as)
+      size as = {!!}
 
     open Dimension ⦃...⦄
 
@@ -1041,13 +883,12 @@
 
     inner-product : ∀ {F} → {{_ : Dimension F}} →
                     F ℕ → F ℕ → ℕ
-    inner-product xs ys = sumAll (zipWith _*_ xs ys)
+    inner-product xs ys = {!!}
 
     matrix-product : ∀ {F G H} →
                      {{_ : Dimension F}}{{_ : Dimension G}}{{_ : Dimension H}} →
                      F (G ℕ) → G (H ℕ) → F (H ℕ)
-    matrix-product {F}{G}{H} {{dimF}} xss yss =
-        zipWith (zipWith inner-product) (replicate <$> xss) (replicate (transpose yss))
+    matrix-product {F}{G}{H} {{dimF}} xss yss = {!!}
 
 ..
   ::
@@ -1237,77 +1078,29 @@
 
 As a result, a shapely list of functors is itself a dimension.
 
-.. BEGIN HIDE
-  ::
-    module Exercise-instances where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 3)** Show that a shapely hyper-matrix has a dimension::
 
-      HyperFunctor : ∀ {Fs} → Shapely Fs → Functor (Hyper Fs)
-      HyperFunctor shapes = {!!}
-
-      HyperApplicative : ∀ {Fs} → Shapely Fs → Applicative (Hyper Fs)
-      HyperApplicative shapes = {!!}
-
-      HyperNaperian : ∀ {Fs} → Shapely Fs → Naperian (Hyper Fs)
-      HyperNaperian shapes = {!!}
-
-      HyperFoldable : ∀ {Fs} → Shapely Fs → Foldable (Hyper Fs)
-      HyperFoldable shapes = {!!}
-
-      HyperTraversable : ∀ {Fs} → Shapely Fs → Traversable (Hyper Fs)
-      HyperTraversable shapes = {!!}
+    HyperFunctor : ∀ {Fs} → Shapely Fs → Functor (Hyper Fs)
+    HyperFunctor shapes = {!!}
 
-      HyperDimension : ∀ {Fs} → Shapely Fs → Dimension (Hyper Fs)
-      HyperDimension shapes = {!!}
+    HyperApplicative : ∀ {Fs} → Shapely Fs → Applicative (Hyper Fs)
+    HyperApplicative shapes = {!!}
 
-.. END BLOCK
+    HyperNaperian : ∀ {Fs} → Shapely Fs → Naperian (Hyper Fs)
+    HyperNaperian shapes = {!!}
 
-.. BEGIN HIDE
-  ::
-    module Solution-instances where
-
-      HyperProp : ∀ {Fs} → Shapely Fs → (Prop : (Set → Set) → Set₁) →
-                    {{ _ : Prop Id}} →
-                    {{ _ : ∀ {F G} → {{_ : Prop F}}{{ _ : Prop G}} → Prop (Seq F G)}} →
-                    (∀ {F} → Dimension F → Prop F) → Prop (Hyper Fs)
-      HyperProp {[]} tt Prop {{pscalar}} pdim = pscalar
-      HyperProp {F ∷ Fs} (dimF , shapeFs) Prop {{pscalar}}{{pcomp}} pdim =
-                let instance recP : Prop (Hyper Fs)
-                             recP = HyperProp {Fs} shapeFs Prop {{pscalar}} {{pcomp}} pdim
-                             f : Prop F
-                             f = pdim dimF
-                in pcomp
-
-      HyperFunctor : ∀ {Fs} → Shapely Fs → Functor (Hyper Fs)
-      HyperFunctor shapes = HyperProp shapes Functor
-                                      (Applicative.super ∘ Dimension.super₁)
-
-      HyperApplicative : ∀ {Fs} → Shapely Fs → Applicative (Hyper Fs)
-      HyperApplicative shapes = HyperProp shapes Applicative
-                                          (Dimension.super₁)
+    HyperFoldable : ∀ {Fs} → Shapely Fs → Foldable (Hyper Fs)
+    HyperFoldable shapes = {!!}
 
-      HyperNaperian : ∀ {Fs} → Shapely Fs → Naperian (Hyper Fs)
-      HyperNaperian shapes = HyperProp shapes Naperian
-                                       Dimension.super₂
+    HyperTraversable : ∀ {Fs} → Shapely Fs → Traversable (Hyper Fs)
+    HyperTraversable shapes = {!!}
 
-      HyperFoldable : ∀ {Fs} → Shapely Fs → Foldable (Hyper Fs)
-      HyperFoldable shapes = HyperProp shapes Foldable
-                                       (Traversable.super ∘ Dimension.super₃)
+    HyperDimension : ∀ {Fs} → Shapely Fs → Dimension (Hyper Fs)
+    HyperDimension shapes = {!!}
 
-      HyperTraversable : ∀ {Fs} → Shapely Fs → Traversable (Hyper Fs)
-      HyperTraversable shapes = HyperProp shapes Traversable
-                                          Dimension.super₃
 
-      HyperDimension : ∀ {Fs} → Shapely Fs → Dimension (Hyper Fs)
-      HyperDimension shapes = HyperProp shapes Dimension id
-
-    open Solution-instances
-
-.. END HIDE
 
 As a result, we can define::
 
@@ -1316,7 +1109,7 @@
 
 and seamlessly apply it to any hyper-matrix.
 
-We can also define the generalized running sum::
+We can also define the generalized running sum:
 
     sums : ∀ {F Fs}
              {{_ : Shapely Fs}}{{_ : Dimension F}} →
@@ -1367,6 +1160,7 @@
                              ((10 ∷ 12 ∷ []) ∷ []))))
         example7 = refl
 
+        {-
         example10 : sums v123
                       ≡ S (I (1 ∷ 3 ∷ 6 ∷ []))
         example10 = refl
@@ -1375,7 +1169,7 @@
                       ≡ S (S (I ((1 ∷ 3 ∷ 6 ∷ []) ∷
                                  (4 ∷ 9 ∷ 15 ∷ []) ∷ [])))
         example11 = refl
-
+        -}
 
 We can also iterate over all "rows" of an hyper-matrix, bringing the
 dimension down by ``F``::
@@ -1383,7 +1177,7 @@
     reduceBy : ∀ {F Fs A M} →
                  {{_ : Shapely Fs}}{{_ : Monoid M}}{{_ : Dimension F}} →
                  (A → M) → Hyper (F ∷ Fs) A → Hyper Fs M
-    reduceBy {{shapeFs}} f (S fga) = (foldMap f) <$>H fga
+    reduceBy {{shapeFs}} f fga = {!!}
         where open Functor (HyperFunctor shapeFs) renaming (_<$>_ to _<$>H_)
 
     sum : ∀ {F Fs} →
@@ -1409,7 +1203,7 @@
     transpose' : ∀ {A F G Fs} →
                  {{_ : Shapely Fs}}{{_ : Dimension F}}{{_ : Dimension G}} →
                  Hyper (F ∷ G ∷ Fs) A → Hyper (G ∷ F ∷ Fs) A
-    transpose' {{shapeFs}} (S (S x)) = S (S (transpose <$>H x))
+    transpose' {{shapeFs}} x = {!!}
         where open Functor (HyperFunctor shapeFs) renaming (_<$>_ to _<$>H_)
 
     _`¹_ : ∀ {A F₁ F₂ Fs G₁ G₂ Gs} →
@@ -1439,15 +1233,11 @@
                                    ((6 ∷ (8 ∷ [])) ∷ [])) ∷ [])))))
         example12b = refl
 
+        {-
         example12 : sums `¹ v123-456 ≡ S (S (I ((1 ∷ 2 ∷ 3 ∷ []) ∷
                                                 (5 ∷ 7 ∷ 9 ∷ []) ∷ [])))
         example12 = refl
-
-.. BEGIN HIDE
-.. TODO: need alignment to automatically  lift the inner value
-      example12 : sum `1 v123-456 ≡ S (I (5 ∷ 7 ∷ 9 ∷ []))
-      example12 = refl
-.. END HIDE
+        -}
 
 At this stage, we are merely touching upon what Gibbons' talks about
 in `APLicative Programming Naperian Functors`_. For instance, when
@@ -1572,79 +1362,28 @@
       correctness-∘ = {!!}
         where postulate ext : Extensionality Level.zero Level.zero
 
-.. BEGIN HIDE
-  ::
-    module Exercise-map where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 2)** We claim that our description interpret
 to functors. We ought to be able to equip *any* description with a
 functorial action::
 
-      map : ∀ {X Y} → (D : Desc)(f : X → Y)(v : ⟦ D ⟧ X) → ⟦ D ⟧ Y
-      map = {!!}
+    map : ∀ {X Y} → (D : Desc)(f : X → Y)(v : ⟦ D ⟧ X) → ⟦ D ⟧ Y
+    map = {!!}
 
 and (generically) prove the functor laws::
 
-      proof-map-id : ∀ {X} → (D : Desc)(v : ⟦ D ⟧ X) → map D id v ≡ v
-      proof-map-id = {!!}
-        where postulate ext : Extensionality Level.zero Level.zero
-
-      proof-map-compos : ∀ {X Y Z}{f : X → Y}{g : Y → Z} →
-                         (D : Desc)(v : ⟦ D ⟧ X) →
-                         map D (λ x → g (f x)) v ≡ map D g (map D f v)
-      proof-map-compos = {!!}
-        where postulate ext : Extensionality Level.zero Level.zero
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
-
-    map : ∀ {X Y} → (D : Desc)(f : X → Y)(v : ⟦ D ⟧ X) → ⟦ D ⟧ Y
-    map `X f x = f x
-    map (`K S) f s = s
-    map (D₁ `× D₂) f (xs₁ , xs₂) = map D₁ f xs₁ , map D₂ f xs₂
-    map (D₁ `+ D₂) f (inj₁ xs₁) = inj₁ (map D₁ f xs₁)
-    map (D₁ `+ D₂) f (inj₂ xs₂) = inj₂ (map D₂ f xs₂)
-    map (`Σ S T) f (a , xs) = a , map (T a) f xs
-    map (`Π S T) f k = λ x → map (T x) f (k x)
-
     proof-map-id : ∀ {X} → (D : Desc)(v : ⟦ D ⟧ X) → map D id v ≡ v
-    proof-map-id `X v = refl
-    proof-map-id (`K S) v = refl
-    proof-map-id (D₁ `× D₂) (xs₁ , xs₂)
-      rewrite proof-map-id D₁ xs₁
-           |  proof-map-id D₂ xs₂  = refl
-    proof-map-id (D₁ `+ D₂) (inj₁ xs₁)
-      rewrite proof-map-id D₁ xs₁ = refl
-    proof-map-id (D₁ `+ D₂) (inj₂ xs₂)
-      rewrite proof-map-id D₂ xs₂ = refl
-    proof-map-id (`Σ S T) (a , b)
-      rewrite proof-map-id (T a) b = refl
-    proof-map-id (`Π S T) k = ext (λ a → proof-map-id (T a) (k a))
+    proof-map-id = {!!}
       where postulate ext : Extensionality Level.zero Level.zero
 
     proof-map-compos : ∀ {X Y Z}{f : X → Y}{g : Y → Z} →
                        (D : Desc)(v : ⟦ D ⟧ X) →
                        map D (λ x → g (f x)) v ≡ map D g (map D f v)
-    proof-map-compos `X v = refl
-    proof-map-compos (`K K) v = refl
-    proof-map-compos {f = f}{g = g} (D₁ `× D₂) (v₁ , v₂)
-      rewrite proof-map-compos {f = f}{g} D₁ v₁
-            | proof-map-compos {f = f}{g} D₂ v₂ = refl
-    proof-map-compos {f = f}{g = g} (D₁ `+ D₂) (inj₁ v₁)
-      rewrite proof-map-compos {f = f}{g} D₁ v₁ = refl
-    proof-map-compos {f = f}{g = g} (D₁ `+ D₂) (inj₂ v₂)
-      rewrite proof-map-compos {f = f}{g} D₂ v₂ = refl
-    proof-map-compos {f = f}{g} (`Σ S T) (a , b)
-      rewrite proof-map-compos {f = f}{g} (T a) b = refl
-    proof-map-compos (`Π S T) k = ext (λ a → proof-map-compos (T a) (k a))
+    proof-map-compos = {!!}
       where postulate ext : Extensionality Level.zero Level.zero
 
-.. END HIDE
+
 
 --------------------------------
 Fixpoint
@@ -1654,7 +1393,7 @@
 "strictly-positive". We are therefore allowed to take their fixpoint::
 
     data μ (D : Desc) : Set where
-      ⟨_⟩ : ⟦ D ⟧ (μ D) → μ D
+      ⟨_⟩ : {!!} → μ D
 
 Over this (standard) inductive type, we can implement the traditional
 ``fold`` operator::
@@ -1662,7 +1401,7 @@
     {-# TERMINATING #-}
     fold : (D : Desc){T : Set} →
            (⟦ D ⟧ T → T) → μ D → T
-    fold D α ⟨ x ⟩ = α (map D (fold D α) x)
+    fold D α ⟨ x ⟩ = {!!}
 
 **Exercise (difficulty: 3)** Convince the termination checker that
 ``fold`` is indeed terminating. Hint: manually specialize the
@@ -1674,7 +1413,7 @@
     module Example-Nat where
 
 **Example: natural numbers**:: Natural numbers are thus described as
-follows::
+follows:
 
       data NatTag : Set where
         `Ze `Su : NatTag
@@ -1689,7 +1428,7 @@
       pattern ze = ⟨ `Ze , tt ⟩
       pattern su n = ⟨ `Su , n ⟩
 
-Using the ``fold``, we can implement addition over these numbers::
+Using the ``fold``, we can implement addition over these numbers:
 
       plus : Nat → Nat → Nat
       plus x = fold NatD (λ { (`Ze , tt) → x
@@ -1703,7 +1442,7 @@
   ::
     module Example-List where
 
-**Example: lists**:: Similarly, here are lists::
+**Example: lists**:: Similarly, here are lists:
 
       data ListTag : Set where
         `Nil `Cons : ListTag
@@ -1723,27 +1462,6 @@
 
 **Exercise (difficulty: 1)**:: Implement binary trees using descriptions.
 
-.. BEGIN HIDE
-  ::
-    module Example-Tree where
-
-    data TreeConst : Set where
-      `Leaf : TreeConst
-      `Node : TreeConst
-
-    TreeD : Set → Desc
-    TreeD X = `Σ TreeConst (λ { `Leaf → `K ⊤
-                              ; `Node → `K X `× `X `× `X })
-
-    Tree : Set → Set
-    Tree X = μ (TreeD X)
-
-    leaf : {X : Set} → Tree X
-    leaf = ⟨ `Leaf , tt ⟩
-
-    node : {X : Set} → X → Tree X → Tree X → Tree X
-    node x l r = ⟨ `Node , x , l , r ⟩
-.. END HIDE
 
 --------------------------------
 Induction
@@ -1756,25 +1474,13 @@
 
 
     All : ∀{X} → (D : Desc)(P : X → Set) → ⟦ D ⟧ X → Set
-    All `X         P x         = P x
-    All (`K Z)     P x         = ⊤
-    All (D₁ `× D₂) P (d₁ , d₂) = All D₁ P d₁ × All D₂ P d₂
-    All (D₁ `+ D₂) P (inj₁ d₁) = All D₁ P d₁
-    All (D₁ `+ D₂) P (inj₂ d₂) = All D₂ P d₂
-    All (`Σ S T)   P (s , xs)  = All (T s) P xs
-    All (`Π S T)   P k         = ∀ s → All (T s) P (k s)
+    All D P x = {!!}
 
     Rec-μ : ∀ D → RecStruct (μ D) _ _
     Rec-μ D P ⟨ xs ⟩ = All D P xs
 
     all : ∀ {X P} → (D : Desc) → (rec : (x : X) → P x)(x : ⟦ D ⟧ X) → All D P x
-    all `X rec x = rec x
-    all (`K S) rec z = tt
-    all (D₁ `× D₂) rec (d₁ , d₂) = all D₁ rec d₁ , all D₂ rec d₂
-    all (D₁ `+ D₂) rec (inj₁ d₁) = all D₁ rec d₁
-    all (D₁ `+ D₂) rec (inj₂ d₂) = all D₂ rec d₂
-    all (`Σ S T) rec (s , xs) = all (T s) rec xs
-    all (`Π S T) rec k = λ s → all (T s) rec (k s)
+    all D rec x = {!!}
 
     {-# TERMINATING #-}
     rec-μ-builder : ∀{D} → RecursorBuilder (Rec-μ D)
@@ -1790,39 +1496,11 @@
 an obviously terminating manner, or by writing ``induction`` directly
 in terms of ``all``.
 
-.. BEGIN HIDE
-  ::
-    module Induction-Terminating where
-      module Elim (D : Desc)
-                  (P : μ D → Set)
-                  (ms : (x : ⟦ D ⟧ (μ D)) →
-                    All D P x → P ⟨ x ⟩) where
-
-
-        ind : (x : μ D) → P x
-        hyps : (D' : Desc)(xs : ⟦ D' ⟧ (μ D)) → All D' P xs
-
-        ind ⟨ xs ⟩ =  ms xs (hyps D xs)
-
-        hyps `X x = ind x
-        hyps (`K Z) z = tt
-        hyps (D `× D') (d , d') = hyps D d , hyps D' d'
-        hyps (D `+ D') (inj₁ d) = hyps D d
-        hyps (D `+ D') (inj₂ d) = hyps D' d
-        hyps (`Σ S T) (a , b) = hyps (T a) b
-        hyps (`Π S T) f = λ s → hyps (T s) (f s)
-
-      ind : (D : Desc)(P : μ D → Set) →
-            ( (x : ⟦ D ⟧ (μ D)) → All D P x → P ⟨ x ⟩) →
-            (v : μ D) → P v
-      ind D P ms x = Elim.ind D P ms x
-
-.. END HIDE
 
 ..
   ::
     module Example-Plus where
-      open Example-Nat hiding (plus)
+      open Example-Nat -- hiding (plus)
 
 Using induction, we can write any dependently-typed programs or proofs
 over described inductive types: they have become (mostly, modulo the
@@ -1830,7 +1508,7 @@
 not idiomatic Agda) first-class objects.
 
 But we can also take this as a opportunity to understand what we did
-earlier, in a simply-typed setting::
+earlier, in a simply-typed setting:
 
       plus[_∶_] : Nat → Nat → Set
       plus[ m ∶ n ] = Nat
@@ -1855,30 +1533,29 @@
 ``op``::
 
     _*D_ : Desc → Set → Desc
-    D *D X = `Σ Bool λ { true → `K X ; false → D }
+    D *D X = {!!}
 
     Free : Desc → Set → Set
     Free D X = μ (D *D X)
 
     return : ∀ {D X} → X → Free D X
-    return x = ⟨ true , x ⟩
+    return x = {!!}
 
     op : ∀ {D X} → ⟦ D ⟧ (Free D X) → Free D X
-    op xs = ⟨ false , xs ⟩
+    op xs = {!!}
 
 Doing so, the resulting description has a monadic structure, which we
-can realize generically::
+can realize generically:
 
     subst[_∶_∶_] : ∀ {X Y} → (D : Desc) → Free D X → (X → Free D Y) → Set
     subst[_∶_∶_] {X}{Y} D _ _ = Free D Y
 
     subst : ∀ {X Y} → (D : Desc) →
             Free D X → (X → Free D Y) → Free D Y
-    subst {X}{Y} D mx k =
+    subst {X}{Y} D mx k = 
       induction (D *D X) (λ mx₁ → subst[ D ∶ mx ∶ k ])
-        (λ { (true , x) tt → k x
-           ; (false , xs) as → ⟨ false , help D xs as ⟩ })
-        mx
+        {!!}
+        ?
       where help : ∀ {X Y} D → (ds : ⟦ D ⟧ X) → All D (λ _ → Y) ds → ⟦ D ⟧ Y
             help `X ds as = as
             help (`K x) ds as = ds
@@ -1889,7 +1566,7 @@
             help (`Π S D₁) ds as = λ s → help (D₁ s) (ds s) (as s)
 
 ..
-  ::
+  :
     module Example-Free (A : Set)(B : A → Set) where
 
       CallD : Desc
@@ -1912,9 +1589,6 @@
 
 **Exercise (difficulty: 4)**:: Prove the monad laws.
 
-.. BEGIN HIDE
-.. TODO: add Zipper
-.. END HIDE
 
 --------------------------------
 Bootstrap
@@ -1938,12 +1612,7 @@
 inductive type. As such, it can be described::
 
     DescD : Desc
-    DescD =  `K ⊤
-          `+ `K Set
-          `+ (`X `× `X)
-          `+ (`X `× `X)
-          `+ (`Σ Set λ S → `Π S (λ _ → `X))
-          `+ (`Σ Set λ S → `Π S (λ _ → `X))
+    DescD =  ?
 
     Desc' : Set₁
     Desc' = μ DescD
