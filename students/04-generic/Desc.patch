--- 04-generic/Desc.lagda.rst	2019-01-25 10:19:46.702610190 +0100
+++ 04-generic/Desc.student.lagda.rst	2019-02-15 10:23:49.440918648 +0100
@@ -23,19 +23,6 @@
   - Traversable
   - Want more? `Typeclassopedia`_!
 
-.. BEGIN HIDE
-  missing:
-   - Monad transformers,
-   - MonadFix,
-   - Semigroup,
-   - Alternative,
-   - MonadPlus,
-   - Category,
-   - Arrow,
-   - Comonad
-
-.. TODO: resurrect Xavier's applicative examples?
-.. END HIDE
 
 Intensional side of this lecture:
   - reflecting inductive types
@@ -254,13 +241,6 @@
 
 **Exercise (difficulty: 1)** Show that lists define a functor.
 
-.. BEGIN HIDE
-  ::
-    instance
-      ListFunctor : Functor List
-      _<$>_ {{ListFunctor}} f [] = []
-      _<$>_ {{ListFunctor}} f (x ∷ xs) = f x ∷ (f <$> xs)
-.. END HIDE
 
 **Exercise (difficulty: 1)** We define::
 
@@ -271,11 +251,6 @@
 
 Let ``A : Set``. Is ``Arrow A : Set → Set`` an endofunctor on ``Set``?
 
-.. BEGIN HIDE
-  ::
-    ArrowFunctor : ∀ {A} → Functor (Arrow A)
-    _<$>_ {{ArrowFunctor}} f (ar g) = ar (f ∘ g)
-.. END HIDE
 
 
 **Exercise (difficulty: 1)** We define::
@@ -290,18 +265,6 @@
 
 **Exercise (difficulty: 3)** Constructively prove your above answer.
 
-.. BEGIN HIDE
-  ::
-    open import Data.Empty
-
-    pf-CoArrow-not-Functor : Functor (CoArrow ⊥) → ⊥
-    pf-CoArrow-not-Functor F = CoArrow.apply (f <$>F x) tt
-        where open Functor F renaming (_<$>_ to _<$>F_)
-              f : ⊥ → ⊤
-              f _ = tt
-              x : CoArrow ⊥ ⊥
-              x = co λ falso → falso
-.. END HIDE
 
 --------------------------------
 Applicative
@@ -422,9 +385,6 @@
                                           let (x , s'') = xs s' in
                                           f x , s''
 
-.. BEGIN HIDE
-.. TODO: write the instances above (<$>, pure and ⊛) using the monadic operations
-.. END HIDE
 
 **Exercise (difficulty: 1)** Write a program that takes a monad (specified with ``return`` and ``>>=``) and produces its underlying applicative.
 
@@ -438,18 +398,6 @@
 
 Let ``A : Set``. Is ``PPair A : Set → Set`` an endofunctor on ``Set``? Is it an applicative?
 
-.. BEGIN HIDE
-  ::
-
-    PPairFunctor : ∀ {A} → Functor (PPair A)
-    _<$>_ {{PPairFunctor}} f ⟨ x , y ⟩ = ⟨ x , f y ⟩
-
-    pf-PPair-not-Applicative : Applicative (PPair ⊥) → ⊥
-    pf-PPair-not-Applicative A = PPair.fst x
-      where open Applicative A renaming (pure to pure-A)
-            x : PPair ⊥ ⊤
-            x = pure-A tt
-.. END HIDE
 
 **Exercise (difficulty: 2)** We define::
 
@@ -465,9 +413,6 @@
 enabling us to parse context-free grammars (ie. regular
 expressions). Is it (necessarily) a monad?
 
-.. BEGIN HIDE
-.. TODO Provide solution
-.. END HIDE
 
 
 --------------------------------
@@ -549,82 +494,16 @@
 **Exercise (difficulty: 2)** State the Naperian laws and prove them
 for vectors.
 
-.. BEGIN HIDE
-  ::
-    record IsNaperian (F : Set → Set){{F-Naperian : Naperian F}} : Set₁ where
-      field
-        tabulate-lookup : ∀ {A} (v : F A) →
-                            tabulate (lookup v)  ≡ v
-        lookup-tabulate : ∀ {A} (f : Log {{F-Naperian}} → A)(l : Log {{F-Naperian}}) →
-                            lookup {{F-Naperian}} (tabulate f) l  ≡ f l
-
-    VectorIsNaperian : ∀{n} → IsNaperian (vec n)
-    VectorIsNaperian = record { tabulate-lookup = tabulate-lookup
-                              ; lookup-tabulate = lookup-tabulate }
-      where tabulate-lookup : ∀ {n A} (v : vec n A) →
-                            tabulate (lookup v)  ≡ v
-            tabulate-lookup [] = refl
-            tabulate-lookup (x ∷ v) rewrite tabulate-lookup v = refl
-
-            lookup-tabulate : ∀ {n A} (f : Fin n → A)(l : Fin n) →
-                            lookup {{VecNaperian}} (tabulate f) l  ≡ f l
-            lookup-tabulate f zero = refl
-            lookup-tabulate f (suc l) rewrite lookup-tabulate (λ n → f (suc n)) l = refl
-.. END HIDE
 
 **Exercise (difficulty: 1)** Show that a Naperian functor is
 necessarily an Applicative functor.
 
-.. BEGIN HIDE
-  ::
-    Naperian→Applicative :  (F : Set → Set){{_ : Naperian F}} → Applicative F
-    pure {{Naperian→Applicative F}} a = tabulate (λ _ → a)
-    _⊛_ {{Naperian→Applicative F}} f a = tabulate (λ ix → (lookup f ix) (lookup a ix))
-.. END HIDE
 
 **Exercise (difficulty: 2)** Show that Naperian functors deserve their
 name: for ``f`` and ``g`` two Naperian functors, define ``Log (f ×
 g)`` and ``Log (f ∘ g)`` in terms of ``Log f`` and ``Log g``. Any
 other remarkable identities?
 
-.. BEGIN HIDE
-  ::
-
-    record Prod (F : Set → Set)(G : Set → Set)(X : Set) : Set where
-      constructor ⟨_,_⟩
-      field
-        fst : F X
-        snd : G X
-
-    ProdFunctor : (F : Set → Set)(G : Set → Set){{_ : Functor F}}{{_ : Functor G}} →
-                    Functor (Prod F G)
-    _<$>_ {{ProdFunctor F G}} f ⟨ x , y ⟩ = ⟨ f <$> x , f <$> y ⟩
-
-    ProdNaperian : (F : Set → Set)(G : Set → Set)
-                    {{_ : Naperian F}}{{_ : Naperian G}} →
-                    Naperian (Prod F G)
-    Log {{ProdNaperian F G {{F-Naperian}} {{G-Naperian}}}} = Log {{F-Naperian}} ⊎ Log {{G-Naperian}}
-    lookup {{ProdNaperian F G}} ⟨ x , y ⟩ ( inj₁ ix) = lookup x ix
-    lookup {{ProdNaperian F G}} ⟨ x , y ⟩ ( inj₂ jx) = lookup y jx
-    tabulate {{ProdNaperian F G}} f = ⟨ tabulate (λ x → f (inj₁ x)) , tabulate (λ x → f (inj₂ x)) ⟩
-    super {{ProdNaperian F G}} = ProdFunctor F G
-
-    data Comp(F : Set → Set) (G : Set → Set)(X : Set) : Set where
-      C : F (G X) → Comp F G X
-
-    CompFunctor : (F : Set → Set)(G : Set → Set){{_ : Functor F}}{{_ : Functor G}} →
-                    Functor (Comp F G)
-    _<$>_ {{CompFunctor F G {{F-Functor}}{{G-Functor}}}} f (C x) = C ((_<$>_ f) <$> x)
-
-    CompNaperian : (F : Set → Set)(G : Set → Set)
-                    {{_ : Naperian F}}{{_ : Naperian G}} →
-                    Naperian (Comp F G)
-    Log {{CompNaperian F G {{F-Naperian}} {{G-Naperian}}}} = Log {{F-Naperian}} × Log {{G-Naperian}}
-    lookup {{CompNaperian F G}} (C x) (ix , jx) = lookup (lookup x ix) jx
-    tabulate {{CompNaperian F G}} f = C (tabulate (λ ix → tabulate (λ jx → f (ix , jx))))
-    super {{CompNaperian F G}} = CompFunctor F G
-
-.. END HIDE
 
 Pairs are Naperian too::
 
@@ -637,13 +516,6 @@
 
 **Exercise (difficulty: 1)** Give an example of a Functor that is **not** Naperian.
 
-.. BEGIN HIDE
-
-  Any structure that cannot be statically indexed (in a total manner)
-  will do the trick. For example, lists or any kind of data-structure
-  whose size is unknown at compile-time.
-
-.. END HIDE
 
 
 Given any pair of Naperian functors, transposition is expressed as
@@ -698,11 +570,6 @@
         id-right : (a : A) → mempty <> a ≡ a
         assoc : (a b c : A) → (a <> b) <> c ≡ a <> (b <> c)
 
-.. BEGIN HIDE
-.. TODO: activate?
-.. {-# DISPLAY Monoid.mempty _ = mempty #-}
-.. {-# DISPLAY Monoid._<>_ _ a b = a <> b #-}
-.. END HIDE
 
 Famous monoids include ``(ℕ, 0, _+_)`` and ``(List A, [], _++_)``
 (also called the free monoid)::
@@ -790,9 +657,6 @@
       VecFoldable : ∀ {n} → Foldable (λ A → Vec A n)
       foldMap {{VecFoldable}} = foldMap-Vec
 
-.. BEGIN HIDE
-.. TODO add equational theory
-.. END HIDE
 
 Pairs are foldable too::
 
@@ -802,13 +666,6 @@
 
 **Exercise (difficulty: 1)** Show that lists are foldable.
 
-.. BEGIN HIDE
-  ::
-    instance
-      ListFoldable : Foldable List
-      foldMap {{ListFoldable}} f [] = mempty
-      foldMap {{ListFoldable}} f (x ∷ xs) = f x <> foldMap f xs
-.. END HIDE
 
 ..
   ::
@@ -875,9 +732,6 @@
       traverse {{VectorTraversable}} f [] = pure []
       traverse {{VectorTraversable}} f (x ∷ v) = _∷_ <$> f x ⊛ traverse f v
 
-.. BEGIN HIDE
-.. TODO add equational theory
-.. END HIDE
 
 Surprise, pairs are traversable too::
 
@@ -1237,77 +1091,29 @@
 
 As a result, a shapely list of functors is itself a dimension.
 
-.. BEGIN HIDE
-  ::
-    module Exercise-instances where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 3)** Show that a shapely hyper-matrix has a dimension::
 
-      HyperFunctor : ∀ {Fs} → Shapely Fs → Functor (Hyper Fs)
-      HyperFunctor shapes = {!!}
-
-      HyperApplicative : ∀ {Fs} → Shapely Fs → Applicative (Hyper Fs)
-      HyperApplicative shapes = {!!}
+    HyperFunctor : ∀ {Fs} → Shapely Fs → Functor (Hyper Fs)
+    HyperFunctor shapes = {!!}
 
-      HyperNaperian : ∀ {Fs} → Shapely Fs → Naperian (Hyper Fs)
-      HyperNaperian shapes = {!!}
+    HyperApplicative : ∀ {Fs} → Shapely Fs → Applicative (Hyper Fs)
+    HyperApplicative shapes = {!!}
 
-      HyperFoldable : ∀ {Fs} → Shapely Fs → Foldable (Hyper Fs)
-      HyperFoldable shapes = {!!}
+    HyperNaperian : ∀ {Fs} → Shapely Fs → Naperian (Hyper Fs)
+    HyperNaperian shapes = {!!}
 
-      HyperTraversable : ∀ {Fs} → Shapely Fs → Traversable (Hyper Fs)
-      HyperTraversable shapes = {!!}
+    HyperFoldable : ∀ {Fs} → Shapely Fs → Foldable (Hyper Fs)
+    HyperFoldable shapes = {!!}
 
-      HyperDimension : ∀ {Fs} → Shapely Fs → Dimension (Hyper Fs)
-      HyperDimension shapes = {!!}
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
-    module Solution-instances where
+    HyperTraversable : ∀ {Fs} → Shapely Fs → Traversable (Hyper Fs)
+    HyperTraversable shapes = {!!}
 
-      HyperProp : ∀ {Fs} → Shapely Fs → (Prop : (Set → Set) → Set₁) →
-                    {{ _ : Prop Id}} →
-                    {{ _ : ∀ {F G} → {{_ : Prop F}}{{ _ : Prop G}} → Prop (Seq F G)}} →
-                    (∀ {F} → Dimension F → Prop F) → Prop (Hyper Fs)
-      HyperProp {[]} tt Prop {{pscalar}} pdim = pscalar
-      HyperProp {F ∷ Fs} (dimF , shapeFs) Prop {{pscalar}}{{pcomp}} pdim =
-                let instance recP : Prop (Hyper Fs)
-                             recP = HyperProp {Fs} shapeFs Prop {{pscalar}} {{pcomp}} pdim
-                             f : Prop F
-                             f = pdim dimF
-                in pcomp
+    HyperDimension : ∀ {Fs} → Shapely Fs → Dimension (Hyper Fs)
+    HyperDimension shapes = {!!}
 
-      HyperFunctor : ∀ {Fs} → Shapely Fs → Functor (Hyper Fs)
-      HyperFunctor shapes = HyperProp shapes Functor
-                                      (Applicative.super ∘ Dimension.super₁)
 
-      HyperApplicative : ∀ {Fs} → Shapely Fs → Applicative (Hyper Fs)
-      HyperApplicative shapes = HyperProp shapes Applicative
-                                          (Dimension.super₁)
-
-      HyperNaperian : ∀ {Fs} → Shapely Fs → Naperian (Hyper Fs)
-      HyperNaperian shapes = HyperProp shapes Naperian
-                                       Dimension.super₂
-
-      HyperFoldable : ∀ {Fs} → Shapely Fs → Foldable (Hyper Fs)
-      HyperFoldable shapes = HyperProp shapes Foldable
-                                       (Traversable.super ∘ Dimension.super₃)
-
-      HyperTraversable : ∀ {Fs} → Shapely Fs → Traversable (Hyper Fs)
-      HyperTraversable shapes = HyperProp shapes Traversable
-                                          Dimension.super₃
-
-      HyperDimension : ∀ {Fs} → Shapely Fs → Dimension (Hyper Fs)
-      HyperDimension shapes = HyperProp shapes Dimension id
-
-    open Solution-instances
-
-.. END HIDE
 
 As a result, we can define::
 
@@ -1443,11 +1249,6 @@
                                                 (5 ∷ 7 ∷ 9 ∷ []) ∷ [])))
         example12 = refl
 
-.. BEGIN HIDE
-.. TODO: need alignment to automatically  lift the inner value
-      example12 : sum `1 v123-456 ≡ S (I (5 ∷ 7 ∷ 9 ∷ []))
-      example12 = refl
-.. END HIDE
 
 At this stage, we are merely touching upon what Gibbons' talks about
 in `APLicative Programming Naperian Functors`_. For instance, when
@@ -1572,79 +1373,28 @@
       correctness-∘ = {!!}
         where postulate ext : Extensionality Level.zero Level.zero
 
-.. BEGIN HIDE
-  ::
-    module Exercise-map where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 2)** We claim that our description interpret
 to functors. We ought to be able to equip *any* description with a
 functorial action::
 
-      map : ∀ {X Y} → (D : Desc)(f : X → Y)(v : ⟦ D ⟧ X) → ⟦ D ⟧ Y
-      map = {!!}
+    map : ∀ {X Y} → (D : Desc)(f : X → Y)(v : ⟦ D ⟧ X) → ⟦ D ⟧ Y
+    map = {!!}
 
 and (generically) prove the functor laws::
 
-      proof-map-id : ∀ {X} → (D : Desc)(v : ⟦ D ⟧ X) → map D id v ≡ v
-      proof-map-id = {!!}
-        where postulate ext : Extensionality Level.zero Level.zero
-
-      proof-map-compos : ∀ {X Y Z}{f : X → Y}{g : Y → Z} →
-                         (D : Desc)(v : ⟦ D ⟧ X) →
-                         map D (λ x → g (f x)) v ≡ map D g (map D f v)
-      proof-map-compos = {!!}
-        where postulate ext : Extensionality Level.zero Level.zero
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
-
-    map : ∀ {X Y} → (D : Desc)(f : X → Y)(v : ⟦ D ⟧ X) → ⟦ D ⟧ Y
-    map `X f x = f x
-    map (`K S) f s = s
-    map (D₁ `× D₂) f (xs₁ , xs₂) = map D₁ f xs₁ , map D₂ f xs₂
-    map (D₁ `+ D₂) f (inj₁ xs₁) = inj₁ (map D₁ f xs₁)
-    map (D₁ `+ D₂) f (inj₂ xs₂) = inj₂ (map D₂ f xs₂)
-    map (`Σ S T) f (a , xs) = a , map (T a) f xs
-    map (`Π S T) f k = λ x → map (T x) f (k x)
-
     proof-map-id : ∀ {X} → (D : Desc)(v : ⟦ D ⟧ X) → map D id v ≡ v
-    proof-map-id `X v = refl
-    proof-map-id (`K S) v = refl
-    proof-map-id (D₁ `× D₂) (xs₁ , xs₂)
-      rewrite proof-map-id D₁ xs₁
-           |  proof-map-id D₂ xs₂  = refl
-    proof-map-id (D₁ `+ D₂) (inj₁ xs₁)
-      rewrite proof-map-id D₁ xs₁ = refl
-    proof-map-id (D₁ `+ D₂) (inj₂ xs₂)
-      rewrite proof-map-id D₂ xs₂ = refl
-    proof-map-id (`Σ S T) (a , b)
-      rewrite proof-map-id (T a) b = refl
-    proof-map-id (`Π S T) k = ext (λ a → proof-map-id (T a) (k a))
+    proof-map-id = {!!}
       where postulate ext : Extensionality Level.zero Level.zero
 
     proof-map-compos : ∀ {X Y Z}{f : X → Y}{g : Y → Z} →
                        (D : Desc)(v : ⟦ D ⟧ X) →
                        map D (λ x → g (f x)) v ≡ map D g (map D f v)
-    proof-map-compos `X v = refl
-    proof-map-compos (`K K) v = refl
-    proof-map-compos {f = f}{g = g} (D₁ `× D₂) (v₁ , v₂)
-      rewrite proof-map-compos {f = f}{g} D₁ v₁
-            | proof-map-compos {f = f}{g} D₂ v₂ = refl
-    proof-map-compos {f = f}{g = g} (D₁ `+ D₂) (inj₁ v₁)
-      rewrite proof-map-compos {f = f}{g} D₁ v₁ = refl
-    proof-map-compos {f = f}{g = g} (D₁ `+ D₂) (inj₂ v₂)
-      rewrite proof-map-compos {f = f}{g} D₂ v₂ = refl
-    proof-map-compos {f = f}{g} (`Σ S T) (a , b)
-      rewrite proof-map-compos {f = f}{g} (T a) b = refl
-    proof-map-compos (`Π S T) k = ext (λ a → proof-map-compos (T a) (k a))
+    proof-map-compos = {!!}
       where postulate ext : Extensionality Level.zero Level.zero
 
-.. END HIDE
+
 
 --------------------------------
 Fixpoint
@@ -1723,27 +1473,6 @@
 
 **Exercise (difficulty: 1)**:: Implement binary trees using descriptions.
 
-.. BEGIN HIDE
-  ::
-    module Example-Tree where
-
-    data TreeConst : Set where
-      `Leaf : TreeConst
-      `Node : TreeConst
-
-    TreeD : Set → Desc
-    TreeD X = `Σ TreeConst (λ { `Leaf → `K ⊤
-                              ; `Node → `K X `× `X `× `X })
-
-    Tree : Set → Set
-    Tree X = μ (TreeD X)
-
-    leaf : {X : Set} → Tree X
-    leaf = ⟨ `Leaf , tt ⟩
-
-    node : {X : Set} → X → Tree X → Tree X → Tree X
-    node x l r = ⟨ `Node , x , l , r ⟩
-.. END HIDE
 
 --------------------------------
 Induction
@@ -1790,34 +1519,6 @@
 an obviously terminating manner, or by writing ``induction`` directly
 in terms of ``all``.
 
-.. BEGIN HIDE
-  ::
-    module Induction-Terminating where
-      module Elim (D : Desc)
-                  (P : μ D → Set)
-                  (ms : (x : ⟦ D ⟧ (μ D)) →
-                    All D P x → P ⟨ x ⟩) where
-
-
-        ind : (x : μ D) → P x
-        hyps : (D' : Desc)(xs : ⟦ D' ⟧ (μ D)) → All D' P xs
-
-        ind ⟨ xs ⟩ =  ms xs (hyps D xs)
-
-        hyps `X x = ind x
-        hyps (`K Z) z = tt
-        hyps (D `× D') (d , d') = hyps D d , hyps D' d'
-        hyps (D `+ D') (inj₁ d) = hyps D d
-        hyps (D `+ D') (inj₂ d) = hyps D' d
-        hyps (`Σ S T) (a , b) = hyps (T a) b
-        hyps (`Π S T) f = λ s → hyps (T s) (f s)
-
-      ind : (D : Desc)(P : μ D → Set) →
-            ( (x : ⟦ D ⟧ (μ D)) → All D P x → P ⟨ x ⟩) →
-            (v : μ D) → P v
-      ind D P ms x = Elim.ind D P ms x
-
-.. END HIDE
 
 ..
   ::
@@ -1912,9 +1613,6 @@
 
 **Exercise (difficulty: 4)**:: Prove the monad laws.
 
-.. BEGIN HIDE
-.. TODO: add Zipper
-.. END HIDE
 
 --------------------------------
 Bootstrap
