--- 01-effectful/Monad.lagda.rst	2019-02-01 13:00:56.494639525 +0100
+++ 01-effectful/Monad.student.lagda.rst	2019-02-15 10:23:08.830265164 +0100
@@ -123,50 +123,23 @@
       `get : ⊤ × (S → X) → ΣState X
       `set : S × (⊤ → X) → ΣState X
 
-.. BEGIN HIDE
-  ::
-    module Exercise-Func where
-.. END HIDE
 
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 1)** Note that this type defines an endofunctor on ``Set``::
 
-      ΣState-map : ∀{V W} → (V → W) → ΣState V → ΣState W
-      ΣState-map f s = {!!}
-
-      ΣState-map-id : ∀{V} (x : ΣState V) →
-                        ΣState-map (λ xs → xs) x ≡ x
-      ΣState-map-id = {!!}
-
-      ΣState-map-∘ : ∀{U V W} (f : U → V)(g : V → W)(x : ΣState U) →
-                     ΣState-map (g ∘ f) x ≡ ΣState-map g (ΣState-map f x)
-      ΣState-map-∘ = {!!}
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
+    ΣState-map : ∀{V W} → (V → W) → ΣState V → ΣState W
+    ΣState-map f s = {!!}
 
-    module Solution-Func where
-        ΣState-map : ∀{V W} → (V → W) → ΣState V → ΣState W
-        ΣState-map f (`get (tt , k)) = `get (tt , λ s → f (k s))
-        ΣState-map f (`set (s , k)) = `set (s , λ tt → f (k tt))
+    ΣState-map-id : ∀{V} (x : ΣState V) →
+                      ΣState-map (λ xs → xs) x ≡ x
+    ΣState-map-id = {!!}
+
+    ΣState-map-∘ : ∀{U V W} (f : U → V)(g : V → W)(x : ΣState U) →
+                   ΣState-map (g ∘ f) x ≡ ΣState-map g (ΣState-map f x)
+    ΣState-map-∘ = {!!}
 
-        ΣState-map-id : ∀{V} (x : ΣState V) →
-                        ΣState-map (λ xs → xs) x ≡ x
-        ΣState-map-id (`get x) = refl
-        ΣState-map-id (`set x) = refl
 
-        ΣState-map-∘ : ∀{U V W} (f : U → V)(g : V → W)(x : ΣState U) →
-                     ΣState-map (g ∘ f) x ≡ ΣState-map g (ΣState-map f x)
-        ΣState-map-∘ f g (`get x) = refl
-        ΣState-map-∘ f g (`set x) = refl
-
-    open Solution-Func
-
-.. END HIDE
 
 **Remark:** an equivalent (but more modular) way to obtain the same
 signature is through the following constructs::
@@ -210,42 +183,21 @@
     get : ⊤ → StateF S
     get tt = op (`get (tt , λ s → return s))
 
-.. BEGIN HIDE
-  ::
-    module Exercise-set where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 1)** Implement `set`::
 
-      set : S → StateF ⊤
-      set s = {!!}
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
-    module Solution-set where
-
-      set : S → StateF ⊤
-      set s = op (`set (s , λ tt → return tt))
+    set : S → StateF ⊤
+    set s = {!!}
 
-    open Solution-set
 
-.. END HIDE
 
 Note that the type of these operations is exactly what we expect in,
 say, OCaml modulo the presence of ``StateF``. It is useful to think of
 ``StateF`` as a modality on the arrow type, documenting what effects
 the function may perform (aside from computing).
 
-.. BEGIN HIDE
-  ::
-    module Exercise-bind where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 3)** thinking of ``V`` as a set of variables,
 ``StateF V`` denotes stateful computations with variables in ``V``. By
@@ -254,23 +206,11 @@
 programs. Formally, we have that ``StateF`` is a monad (the `free
 monad`_)::
 
-      {-# TERMINATING #-}
-      _>>=_ : ∀{V W} → StateF V → (V → StateF W) → StateF W
-      sv >>= mf = {!!}
-
-.. END BLOCK
+    {-# TERMINATING #-}
+    _>>=_ : ∀{V W} → StateF V → (V → StateF W) → StateF W
+    sv >>= mf = {!!}
 
-.. BEGIN HIDE
-  ::
 
-    module Solution-bind where
-
-      {-# TERMINATING #-}
-      _>>=_ : ∀{V W} → StateF V → (V → StateF W) → StateF W
-      return x >>= mf = mf x
-      op fa >>= mf = op (ΣState-map (λ mv → mv >>= mf) fa)
-
-.. END HIDE
 
 If one thinks of ``V`` and ``W`` as sets of variables, then ``>>=``
 (pronounced **bind**) can be thought as implementing a simultaneous
@@ -283,27 +223,7 @@
 able to check that it is indeed terminating. Hint: use a pair of
 mutually recursive functions.
 
-.. BEGIN HIDE
-  ::
-
-    module Solution-bind-terminating where
 
-      mutual
-        _>>=_ : ∀{V W} → StateF V → (V → StateF W) → StateF W
-        return x >>= mf = mf x
-        op fa >>= mf = op (ΣStatemap mf fa)
-
-        ΣStatemap : ∀{V W} → (V → StateF W) → ΣState (StateF V) → ΣState (StateF W)
-        ΣStatemap mf (`get (tt , k)) = `get (tt , λ s → (k s) >>= mf)
-        ΣStatemap mf (`set (s , k)) = `set (s , λ tt → (k tt) >>= mf)
-
-    open Solution-bind
-
-.. END HIDE
-
-.. BEGIN HIDE
-.. TODO: discuss inefficiency of this implementation. Exercise: codensity
-.. END HIDE
 
 **Remark** there is nothing special about ``StateF``: given any
 (well-behaved) endofunctor ``F : Set → Set``, we can build another
@@ -375,18 +295,6 @@
         (return x >>= k) ≡ k x
       bind-left-unit x k = {!!}
 
-.. BEGIN HIDE
-  ::
-
-    module Solution-bind-left-unit where
-
-      bind-left-unit : ∀ {X Y} → (x : X)(k : X → StateF Y) →
-        (return x >>= k) ≡ k x
-      bind-left-unit x k = refl
-
-    open Solution-bind-left-unit
-
-.. END HIDE
 
 ..
   ::
@@ -402,24 +310,6 @@
       bind-right-unit = {!!}
         where postulate ext : Extensionality Level.zero Level.zero
 
-.. BEGIN HIDE
-  ::
-
-    module Solution-bind-right-unit where
-
-      {-# TERMINATING #-}
-      bind-right-unit : ∀ {X} → (mx : StateF X) →
-                    mx >>= return ≡ mx
-      bind-right-unit (return x) = refl
-      bind-right-unit (op x) = cong≡ op
-                             (trans≡ (cong≡ (λ f → ΣState-map f x)
-                                            (ext bind-right-unit))
-                                     (ΣState-map-id x))
-        where postulate ext : Extensionality Level.zero Level.zero
-
-    open Solution-bind-right-unit
-
-.. END HIDE
 
 This exercise is artificially difficult because of the need to
 convince Agda's termination checker. One should feel free to convince
@@ -441,25 +331,6 @@
       bind-compose = {!!}
         where postulate ext : Extensionality Level.zero Level.zero
 
-.. BEGIN HIDE
-  ::
-
-    module Solution-bind-compose where
-
-      {-# TERMINATING #-}
-      bind-compose : ∀ {X Y Z} → (mx : StateF X)(f : X → StateF Y)(g : Y → StateF Z) →
-        ((mx >>= f) >>= g) ≡ (mx >>= λ x → (f x >>= g))
-      bind-compose (return x) f g = refl
-      bind-compose (op x) f g = cong≡ op
-                               (trans≡ (sym≡ (ΣState-map-∘ (λ mv → mv >>= f)
-                                                           (λ mv → mv  >>= g) x))
-                               (cong≡ (λ f → ΣState-map f x)
-                               (ext (λ mx → bind-compose mx f g))))
-        where postulate ext : Extensionality Level.zero Level.zero
-
-    open Solution-bind-compose
-
-.. END HIDE
 
 There is a familiar object that offers a similar interface: (pure)
 function! For which ``_>>=_`` amounts to composition and ``return`` is
@@ -585,9 +456,6 @@
       prog-equiv : prog1 ∼ prog2
       prog-equiv = {!!}
 
-.. BEGIN HIDE
-.. TODO: I cannot be bothered to produce the witness.
-.. END HIDE
 
 ************************************************
 Semantics: ``State ≡ StateF/∼``
@@ -624,78 +492,36 @@
 to a technique called `normalization-by-evaluation`_, with is spicy
 hot Curry-Howard in action.
 
-.. BEGIN HIDE
-  ::
-    module Exercise-eval where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 2)** the first step is to interpret stateful
 terms into a suitable semantic domain which is **extensionally**
 quotiented by the theory of State::
 
-      eval : ∀{A} → StateF A → STATE A
-      eval = {!!}
+    eval : ∀{A} → StateF A → STATE A
+    eval = {!!}
 
 This function should satisfy the following unit-proofs::
 
-      test-eval-get : ∀ {A} tt (k : S → StateF A) s →
-                   eval (get tt >>= k) s ≡ eval (k s) s
-      test-eval-get = {!!}
-
-      test-eval-set : ∀ {A} (k : ⊤ → StateF A) s s' →
-                   eval (set s' >>= k) s ≡ eval (k tt) s'
-      test-eval-set = {!!}
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
-    module Solution-eval where
-
-      eval : ∀{A} → StateF A → STATE A
-      eval (return a) = λ s → (s , a)
-      eval (op (`get (tt , k))) = λ s → eval (k s) s
-      eval (op (`set (s' , k))) = λ s → eval (k tt) s'
-
-      test-eval-get : ∀ {A} tt (k : S → StateF A) s →
-                   eval (get tt >>= k) s ≡ eval (k s) s
-      test-eval-get tt k s = refl
+    test-eval-get : ∀ {A} tt (k : S → StateF A) s →
+                 eval (get tt >>= k) s ≡ eval (k s) s
+    test-eval-get = {!!}
+
+    test-eval-set : ∀ {A} (k : ⊤ → StateF A) s s' →
+                 eval (set s' >>= k) s ≡ eval (k tt) s'
+    test-eval-set = {!!}
 
-      test-eval-set : ∀ {A} (k : ⊤ → StateF A) s s' →
-                   eval (set s' >>= k) s ≡ eval (k tt) s'
-      test-eval-set k s s' = refl
 
-    open Solution-eval
 
-.. END HIDE
 
-.. BEGIN HIDE
-  ::
-    module Exercise-reify where
-.. END HIDE
-
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 1)** the second step consists in *reifying*
 the semantic objects into the desired normal forms::
 
-      reify : ∀{A} → STATE A → State A
-      reify f = {!!}
+    reify : ∀{A} → STATE A → State A
+    reify f = {!!}
 
-.. END BLOCK
 
-.. BEGIN HIDE
-  ::
-    module Solution-reify where
-
-      reify : ∀{A} → STATE A → State A
-      reify {A} f = `get (tt , λ s → `set (proj₁ (f s) , λ tt → proj₂ (f s)))
-
-    open Solution-reify
-
-.. END HIDE
 
 The normalization procedure thus genuinely computes the normal form::
 
@@ -753,31 +579,6 @@
       test-sem-set : ∀{s s'} → eval (set s') s ≡ sem-set s' s
       test-sem-set = {!!}
 
-.. BEGIN HIDE
-  ::
-    module Solution-sem-monad where
-
-      sem-return : ∀{A} → A → STATE A
-      sem-return a = λ s → (s , a)
-
-      sem-get : ⊤ → STATE S
-      sem-get tt = λ s → (s , s)
-
-      sem-set : S → STATE ⊤
-      sem-set s = λ _ → (s , tt)
-
-      test-sem-return : ∀ {X}{x : X} → eval (return x) ≡ sem-return x
-      test-sem-return = refl
-
-      test-sem-get : ∀{s} → eval (get tt) s ≡ sem-get tt s
-      test-sem-get = refl
-
-      test-sem-set : ∀{s s'} → eval (set s') s ≡ sem-set s' s
-      test-sem-set = refl
-
-    open Solution-sem-monad
-
-.. END HIDE
 
 ..
   ::
@@ -795,21 +596,6 @@
         eval (mx >>= k) s ≡ (eval mx sem->>= λ x → eval (k x)) s
       test-eval-compose = {!!}
 
-.. BEGIN HIDE
-  ::
-    module Solution-sem-bind where
-
-      _sem->>=_ : ∀ {X Y} → (mx : STATE X)(k : X → STATE Y) → STATE Y
-      _sem->>=_ mx k = λ s → let (s' , x) = mx s in k x s'
-
-      test-eval-compose : ∀ {X Y} (mx : StateF X)(k : X → StateF Y) (s : S) →
-        eval (mx >>= k) s ≡ (eval mx sem->>= λ x → eval (k x)) s
-      test-eval-compose (return x) k s = refl
-      test-eval-compose (op x) k s = {!!}
-
-    open Solution-sem-bind
-
-.. END HIDE
 
 In conclusion, we have been able to transport *all* the syntactic
 structure of ``StateF X`` to ``STATE X``. In fact, we could be so bold
@@ -824,127 +610,22 @@
 form. This is captured by two statement, a *soundness* result and a
 *completeness* result.
 
-.. BEGIN HIDE
-  ::
-    module Exercise-sound-complete where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 4)** at first, we assume the following two
 lemmas (whose proof is left as an exercise)::
 
-      pf-sound : ∀{A} → (p : StateF A) → p ∼ ⌈ norm p ⌉
-      pf-sound {A} = {!!}
-          where open import Relation.Binary.EqReasoning (setoid A)
+    pf-sound : ∀{A} → (p : StateF A) → p ∼ ⌈ norm p ⌉
+    pf-sound {A} = {!!}
+        where open import Relation.Binary.EqReasoning (setoid A)
+
+    pf-complete : ∀ {A} {p q : StateF A} → p ∼ q → ∀{s} → eval p s ≡ eval q s
+    pf-complete = {!!}
+      where open ≡-Reasoning
 
-      pf-complete : ∀ {A} {p q : StateF A} → p ∼ q → ∀{s} → eval p s ≡ eval q s
-      pf-complete = {!!}
-        where open ≡-Reasoning
-
-.. END BLOCK
 
 so as to focus on the overall architecture of the proof.
 
-.. BEGIN HIDE
-  ::
-    module Solution-sound-complete where
-
-      pf-sound : ∀{A} → (p : StateF A) → p ∼ ⌈ norm p ⌉
-      pf-complete : ∀ {A} {p q : StateF A} → p ∼ q → ∀{s} → eval p s ≡ eval q s
-
-      pf-sound (return x) = sym (inc get-set)
-      pf-sound {V} (op (`get (tt , k))) =
-        begin
-          op (`get (tt , k))
-        ≡⟨ refl ⟩
-          get tt >>= k
-        ≈⟨ cong (op (`get (tt , return)))
-                (λ s' → pf-sound (k s')) ⟩
-           get tt >>= (λ s' → ⌈ norm (k s') ⌉)
-        ≡⟨ refl ⟩
-          op (`get (tt , λ s' →
-          op (`get (tt , λ s →
-          op (`set (proj₁ (eval (k s') s) , λ _ →
-          return (proj₂ (eval (k s') s))))))))
-        ≈⟨ inc get-get ⟩
-          op (`get (tt , λ s →
-          op (`set (proj₁ (eval (k s) s) , λ _ →
-          return (proj₂ (eval (k s) s))))))
-          ≡⟨ refl ⟩
-          ⌈ norm (op (`get (tt , k))) ⌉
-        ∎
-          where open  import Relation.Binary.EqReasoning (setoid V)
-      pf-sound {V} (op (`set (s' , k))) =
-        begin
-          op (`set (s' , k ))
-        ≈⟨ cong (op (`set (s' , return))) (λ _ → pf-sound (k tt)) ⟩
-          op (`set (s' , λ tt → ⌈ norm (k tt) ⌉) )
-        ≡⟨ refl ⟩
-          op (`set (s' , λ _ →
-          op (`get (tt , λ s →
-          op (`set (proj₁ (eval (k tt) s), λ _ →
-          return (proj₂ (eval (k tt) s))))))))
-        ≈⟨ inc set-get ⟩
-           op (`set (s' , λ _ →
-           op (`set (proj₁ (eval (k tt) s'), λ _ →
-           return (proj₂ (eval (k tt) s'))))))
-        ≈⟨ inc set-set ⟩
-          op (`set (proj₁ (eval (k tt) s'), λ _ →
-          return (proj₂ (eval (k tt) s'))))
-        ≈⟨ sym (inc get-set) ⟩
-          op (`get (tt , λ s →
-          op (`set (s , λ _ →
-          op (`set (proj₁ (eval (k tt) s'), λ _ →
-          return (proj₂ (eval (k tt) s'))))))))
-        ≈⟨ cong (get tt >>= return) (λ s → inc set-set) ⟩
-          op (`get (tt , λ s →
-          op (`set (proj₁ (eval (k tt) s'), λ _ →
-          return (proj₂ (eval (k tt) s'))))))
-          ≡⟨ refl ⟩
-         ⌈ norm (op (`set (s' , k))) ⌉
-           ∎
-         where open import Relation.Binary.EqReasoning (setoid V)
-
-      eval-compose : ∀{A B}(tm : StateF A)(k : A → StateF B){s} →
-                   eval (tm >>= k) s
-                   ≡ (let p : S × A
-                          p = eval tm s in
-                     eval (k (proj₂ p)) (proj₁ p))
-      eval-compose (return x) k {s} = refl
-      eval-compose (op (`get (tt , k))) k' {s} = eval-compose (k s) k'
-      eval-compose (op (`set (s' , k))) k' {s} = eval-compose (k tt) k'
-
-      pf-complete (inc get-get) = refl
-      pf-complete (inc set-set) = refl
-      pf-complete (inc set-get) = refl
-      pf-complete (inc get-set) = refl
-      pf-complete {p = p}{q} (trans {q = r} r₁ r₂) {s} =
-        begin
-          eval p s
-          ≡⟨ pf-complete r₁ ⟩
-        eval r s
-        ≡⟨ pf-complete r₂ ⟩
-           eval q s
-        ∎
-        where open ≡-Reasoning
-      pf-complete refl = refl
-      pf-complete (sym r) = sym≡ (pf-complete r)
-      pf-complete (cong tm {ps}{qs} x) {s} =
-        begin
-          eval (tm >>= ps) s
-        ≡⟨ eval-compose tm ps ⟩
-          eval (ps (proj₂ (eval tm s))) (proj₁ (eval tm s))
-        ≡⟨ pf-complete (x (proj₂ (eval tm s))) ⟩
-          eval (qs (proj₂ (eval tm s))) (proj₁ (eval tm s))
-        ≡⟨ sym≡ (eval-compose tm qs) ⟩
-          eval (tm >>= qs) s
-        ∎
-        where open ≡-Reasoning
-
-    open Solution-sound-complete
-
-.. END HIDE
 
 First, ``norm`` is sound: if two terms have the same normal form, they
 belong to the same congruence class::
@@ -1040,70 +721,9 @@
         ⌈ norm (tm >>= ps) ⌉ ≡ ⌈ norm (⌈ norm tm ⌉ >>= λ w → ⌈ norm (ps  w) ⌉) ⌉
       norm-compose = {!!}
 
-.. BEGIN HIDE
-  ::
-    module Solution-norm-compose where
-
-      norm-compose : ∀{V W}(tm : StateF W)(ps : W → StateF V) →
-        ⌈ norm (tm >>= ps) ⌉ ≡ ⌈ norm (⌈ norm tm ⌉ >>= λ w → ⌈ norm (ps  w) ⌉) ⌉
-      norm-compose tm ps =
-        begin
-          ⌈ norm (tm >>= ps) ⌉
-        ≡⟨ refl ⟩
-          op (`get (tt , λ s →
-          op (`set (let p : S × _
-                        p = eval (tm >>= ps) s in
-          proj₁ p , λ _ → return (proj₂ p)))))
-        ≡⟨ cong≡ (λ k → op (`get (tt , k))) (ext help) ⟩
-          op (`get (tt , λ s →
-          (op (`set (let p₁ : S × _
-                         p₁ = eval tm s
-                         p₂ : S × _
-                         p₂ = eval (ps (proj₂ p₁)) (proj₁ p₁) in
-              proj₁ p₂ , λ _ → return  (proj₂ p₂))))))
-        ≡⟨ refl ⟩
-          ⌈ norm (⌈ norm tm ⌉ >>= λ w → ⌈ norm (ps  w) ⌉) ⌉
-        ∎
-          where postulate ext : Extensionality Level.zero Level.zero
-                open ≡-Reasoning
-                help : (s : S) → (op (`set (let p : S × _
-                                                p = eval (tm >>= ps) s in
-                                     proj₁ p , λ _ → return (proj₂ p))))
-                               ≡ (op (`set (let p₁ : S × _
-                                                p₁ = eval tm s
-                                                p₂ : S × _
-                                                p₂ = eval (ps (proj₂ p₁)) (proj₁ p₁) in
-                                     proj₁ p₂ , λ _ → return  (proj₂ p₂))))
-                help s = cong≡ (λ { (s , k) →  op (`set (s , λ _ → return k)) }) (eval-compose tm ps)
-
-    open Solution-norm-compose
-
-.. END HIDE
 
 **Exercise (difficulty: 2)** Deduce the proof of generalized congruence ``cong₂``.
 
-.. BEGIN HIDE
-  ::
-    cong₂ : ∀{V W}(tm tm' : StateF W){ps qs : W → StateF V}  →
-              (tm ∼ tm') →
-              (∀ w → ps w ∼ qs w) →
-              (tm >>= ps) ∼ (tm' >>= qs)
-    cong₂ {V} tm tm' {ps}{qs} q qp = sound (tm >>= ps) (tm' >>= qs)
-      (begin
-        ⌈ norm (tm >>= ps) ⌉
-      ≡⟨ norm-compose tm ps ⟩
-        ⌈ norm (⌈ norm tm ⌉ >>= λ w → ⌈ norm (ps  w) ⌉) ⌉
-      -- Remark: we are using completeness here!
-      ≡⟨ cong₂≡ (λ t k → ⌈ norm (t >>= k) ⌉)
-                (complete q)
-                (ext (λ w → complete (qp w))) ⟩
-        ⌈ norm (⌈ norm tm' ⌉ >>= λ w → ⌈ norm (qs  w) ⌉) ⌉
-      ≡⟨ sym≡ (norm-compose tm' qs) ⟩
-        ⌈ norm (tm' >>= qs) ⌉
-      ∎)
-        where postulate ext : Extensionality Level.zero Level.zero
-              open ≡-Reasoning
-.. END HIDE
 
 ************************************************
 Application: the Tick monad
@@ -1151,52 +771,24 @@
 Free term algebra
 --------------------------------
 
-.. BEGIN HIDE
-  ::
-    module Exercise-Tick-sig where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 2)** Define the syntax for tickful programs
 using the free term algebra::
 
-      data TickF (V : Set) : Set where
-
-      tick : R → TickF ⊤
-      tick r = {!!}
+    data TickF (V : Set) : Set where
 
-      mutual
-        _>>=_ : ∀{A B} → TickF A → (A → TickF B) → TickF B
-        s >>= mf = {!!}
+    tick : R → TickF ⊤
+    tick r = {!!}
 
-        ΣTickmap : ∀{A B} → (A → TickF B) → ΣTick (TickF A) → ΣTick (TickF B)
-        ΣTickmap mf s = {!!}
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
-    module Solution-Tick-sig where
+    mutual
+      _>>=_ : ∀{A B} → TickF A → (A → TickF B) → TickF B
+      s >>= mf = {!!}
 
-      data TickF (V : Set) : Set where
-        return : V → TickF V
-        op : ΣTick (TickF V) → TickF V
+      ΣTickmap : ∀{A B} → (A → TickF B) → ΣTick (TickF A) → ΣTick (TickF B)
+      ΣTickmap mf s = {!!}
 
-      tick : R → TickF ⊤
-      tick r = op (`tick (r , return))
 
-      mutual
-        _>>=_ : ∀{A B} → TickF A → (A → TickF B) → TickF B
-        return x >>= mf = mf x
-        op fa >>= mf = op (ΣTickmap mf fa)
-
-        ΣTickmap : ∀{A B} → (A → TickF B) → ΣTick (TickF A) → ΣTick (TickF B)
-        ΣTickmap mf (`tick (r , k)) = `tick (r , λ tt → k tt >>= mf)
-
-    open Solution-Tick-sig
-
-.. END HIDE
 
 --------------------------------
 Equational theory
@@ -1233,27 +825,6 @@
 
 **Exercise (difficulty: 3)** Establish this *a posteriori* by normalization-by-evaluation.
 
-.. BEGIN HIDE
-  ::
-    eval : ∀{A} → TickF A → R × A
-    eval (return a) = ε , a
-    eval {A} (op (`tick (r , k))) =
-      let p : R × A
-          p = eval (k tt) in
-       r ∙ (proj₁ p) , proj₂ p
-
-    reify : ∀{A} → R × A → Tick A
-    reify {A} (r , a) = `tick (r , λ _ → a)
-
-    norm : ∀{A} → TickF A → Tick A
-    norm p = reify (eval p)
-
-    ⌈_⌉ : ∀{A} → Tick A → TickF A
-    ⌈ `tick (r , a) ⌉ = tick r >>= λ tt → return (a tt)
-
-.. TODO proof of soundness/completeness left as an exercise
-
-.. END HIDE
 
 ************************************************
 More monads
@@ -1345,16 +916,6 @@
 **Exercise (difficulty: 1)** Implement ``return``, ``_>>=_`` and prove
 the monad laws.
 
-.. BEGIN HIDE
-  ::
-
-      returnC : ∀{X} → X → Count X
-      returnC x = (0 , x)
-
-      _>>=C_ : ∀{X Y} → Count X → (X → Count Y) → Count Y
-      (n , x) >>=C k = let (m , y) = k x in (m + n , y)
-
-.. END HIDE
 
 The ``Count`` monad can be used to **instrument** program, over which
 we can later perform formal reasoning to establish complexity results
@@ -1371,19 +932,6 @@
         insert : ℕ → List ℕ → Count (List ℕ)
         insert n l = {!!}
 
-.. BEGIN HIDE
-  ::
-      module Solution-insert where
-
-
-        insert : ℕ → List ℕ → Count (List ℕ)
-        insert n [] = returnC (n ∷ [])
-        insert n (m ∷ xs) = count (n ≟ m) >>=C (λ {
-                            (yes p) → returnC (n ∷ m ∷ xs) ;
-                            (no ¬p) → insert n xs >>=C λ xs' →
-                                      returnC (m ∷ xs') })
-
-.. END HIDE
 
 --------------------------------
 Writer/logging monad
@@ -1431,16 +979,6 @@
 **Exercise (difficulty: 1)** Implement ``return``, ``_>>=_`` and prove
 the monad laws.
 
-.. BEGIN HIDE
-  ::
-
-      returnN : ∀ {X} → X → Nondet X
-      returnN = {!!}
-
-      _>>=N_ : ∀{X Y} → Nondet X → (X → Nondet Y) → Nondet Y
-      mx >>=N k = {!!}
-
-.. END HIDE
 
 **Exercise (difficulty: 3)** give an algebraic presentation of this
 monad.
@@ -1461,23 +999,6 @@
         permut : ∀{X} → List X → Nondet (List X)
         permut l = {!!}
 
-.. BEGIN HIDE
-  ::
-      module Solution-insert-permut where
-
-        insert : ∀{X} → X → List X → Nondet (List X)
-        insert {X} x l = returnN (x ∷ l)
-                       ∣ split l
-             where split : List X → Nondet (List X)
-                   split [] = fail
-                   split (y ∷ l) = insert x l >>=N λ l' →
-                                   returnN (y ∷ l')
-
-        permut : ∀{X} → List X → Nondet (List X)
-        permut [] = returnN []
-        permut (x ∷ l) = permut l >>=N λ l' → insert x l'
-
-.. END HIDE
 
 --------------------------------
 Random monad
@@ -1517,16 +1038,6 @@
 
 **Exercise (difficulty: 1)** implement ``return`` and ``_>>=_``.
 
-.. BEGIN HIDE
-  ::
-
-      returnR : ∀{X} → X → RandF X
-      returnR = {!!}
-
-      _>>=R_ : ∀{X Y} → RandF X → (X → RandF Y) → RandF Y
-      mx >>=R f = {!!}
-
-.. END HIDE
 
 ..
   ::
@@ -1543,25 +1054,6 @@
         sum : RandF ℕ
         sum = {!!}
 
-.. BEGIN HIDE
-  ::
-      module Solution-dice where
-
-        dice : RandF ℕ
-        dice = rand 6 >>=R λ n → returnR (1 + n)
-
-        sum : RandF ℕ
-        sum = dice >>=R λ d₁ →
-              dice >>=R λ d₂ →
-              dice >>=R λ d₃ →
-              returnR (d₁ + d₂ + d₃)
-
-.. let traffic_light =
-..   M.choose 0.05 (M.ret Yellow)
-..                 (M.choose 0.5 (M.ret Red)
-..                               (M.ret Green))
-
-.. END HIDE
 
 ..
   ::
@@ -1633,19 +1125,7 @@
 **Exercise (difficulty: 1)** Implement ``return``, ``_>>=_`` and prove
 the monad laws.
 
-.. BEGIN HIDE
-
-      returnD : ∀{A} → A → Distr A
-      returnD a = (a , 1.0) ∷ []
-
-.. END HIDE
-
-.. BEGIN HIDE
-
-.. TODO: monad transformers?
-.. TODO: concurrency monad transformer
 
-.. END HIDE
 
 --------------------------------
 CPS monad
@@ -1683,21 +1163,6 @@
 Classics) and `Kan Extensions for Program Optimisation`_ (if you enjoy
 spicing things up with string diagrams).
 
-.. BEGIN HIDE
-
-.. ************************************************
-.. Comonads
-.. ************************************************
-
-.. examples from Orchard et al.
-
-.. ************************************************
-.. Back to λ-calculus
-.. ************************************************
-
-.. monadic translation of lambda-calculus -> CBPV ?
-
-.. END HIDE
 
 
 ************************************************
