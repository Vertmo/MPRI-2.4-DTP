--- 02-dependent/Indexed.lagda.rst	2019-02-08 12:14:54.551772810 +0100
+++ 02-dependent/Indexed.student.lagda.rst	2019-02-15 10:23:20.941865948 +0100
@@ -52,10 +52,6 @@
 Typing ``sprintf``
 ************************************************
 
-.. BEGIN HIDE
-.. TODO: type-system for formats?
-.. sprintf : ∀ {T} → String T → T → String
-.. END HIDE
 
 ..
   ::
@@ -317,11 +313,6 @@
 construction. Implement these source and target languages and the
 correct-by-construction compiler.
 
-.. BEGIN HIDE
-
-.. TODO Write correction
-
-.. END HIDE
 
 --------------------------------
 Correctness
@@ -509,33 +500,6 @@
       lemma-valid : ∀{m n k l} → (wk : m ⊇ n) → k ≤ l → ⟦ wk ⟧ k ≤ ⟦ wk ⟧ l
       lemma-valid = {!!}
 
-.. BEGIN HIDE
-  ::
-
-    module Solution-mono where
-
-      open import Data.Fin
-
-      data _⊇_ : (m : ℕ)(n : ℕ) → Set where
-        id    : ∀ {m} → m ⊇ m
-        weak1 : ∀ {m n} → (wk : m ⊇ n) → suc m ⊇ n
-        weak2 : ∀ {m n} → (wk : m ⊇ n) → suc m ⊇ suc n
-
-
-      ⟦_⟧ : ∀ {m n} → m ⊇ n → Fin n → Fin m
-      ⟦ id ⟧ k = k
-      ⟦ weak1 wk ⟧ v = suc (⟦ wk ⟧ v)
-      ⟦ weak2 wk ⟧ zero = zero
-      ⟦ weak2 wk ⟧ (suc k) = suc (⟦ wk ⟧ k)
-
-      lemma-valid : ∀{m n k l} → (wk : m ⊇ n) → k ≤ l → ⟦ wk ⟧ k ≤ ⟦ wk ⟧ l
-      lemma-valid id p = p
-      lemma-valid (weak1 wk) p = s≤s (lemma-valid wk p)
-      lemma-valid {k = zero}  (weak2 wk) x = z≤n
-      lemma-valid {k = suc k} {zero} (weak2 wk) ()
-      lemma-valid {k = suc k} {suc l} (weak2 wk) (s≤s p) = s≤s (lemma-valid wk p)
-
-.. END HIDE
 
 We can adapt this intentional characterization of monotone functions
 to typed embeddings::
@@ -577,98 +541,30 @@
 metatheory with terms represented by an indexed family of types`_, for
 example.
 
-.. BEGIN HIDE
-  ::
-    module Exercise-compose where
-.. END HIDE
 
-.. BEGIN BLOCK
 
 **Exercise (difficulty: 2)** Weakenings interpret to renaming
 functions and functions do compose so we are naturally driven to
 implement composition directly on renamings::
 
-      _∘wk_ : ∀ {Δ ∇ Γ} → Δ ⊇ ∇ → Γ ⊇ Δ → Γ ⊇ ∇
-      _∘wk_ = {!!}
+    _∘wk_ : ∀ {Δ ∇ Γ} → Δ ⊇ ∇ → Γ ⊇ Δ → Γ ⊇ ∇
+    _∘wk_ = {!!}
 
 And we must make sure, that this notion of composition is the *right*
 one::
 
-      lemma-right-unit : ∀ {Γ Δ} → (wk : Γ ⊇ Δ) → wk ∘wk id ≡ wk
-      lemma-right-unit = {!!}
+    lemma-right-unit : ∀ {Γ Δ} → (wk : Γ ⊇ Δ) → wk ∘wk id ≡ wk
+    lemma-right-unit = {!!}
 
-      lemma-left-unit : ∀ {Γ Δ} → (wk : Γ ⊇ Δ) → id ∘wk wk ≡ wk
-      lemma-left-unit = {!!}
-
-      lemma-assoc : ∀ {Γ Δ ∇ Ω} → (wk₃ : Γ ⊇ Δ)(wk₂ : Δ ⊇ ∇)(wk₁ : ∇ ⊇ Ω) →
-        (wk₁ ∘wk wk₂) ∘wk wk₃ ≡ wk₁ ∘wk (wk₂ ∘wk wk₃)
-      lemma-assoc = {!!}
-
-.. END BLOCK
-
-.. BEGIN HIDE
-  ::
-    module Solution-compose where
+    lemma-left-unit : ∀ {Γ Δ} → (wk : Γ ⊇ Δ) → id ∘wk wk ≡ wk
+    lemma-left-unit = {!!}
 
-      _∘wk_ : ∀ {Δ ∇ Γ} → Δ ⊇ ∇ → Γ ⊇ Δ → Γ ⊇ ∇
-      wk ∘wk id              = wk
-      wk' ∘wk weak1 wk       = weak1 (wk' ∘wk wk)
-      id  ∘wk weak2 wk       = weak2 wk
-      weak1 wk' ∘wk weak2 wk = weak1 (wk' ∘wk wk)
-      weak2 wk' ∘wk weak2 wk = weak2 (wk' ∘wk wk)
-
-      lemma-right-unit : ∀ {Γ Δ} → (wk : Γ ⊇ Δ) → wk ∘wk id ≡ wk
-      lemma-right-unit wk = refl
-
-      lemma-left-unit : ∀ {Γ Δ} → (wk : Γ ⊇ Δ) → id ∘wk wk ≡ wk
-      lemma-left-unit id           = refl
-      lemma-left-unit (weak1 wk)
-        rewrite lemma-left-unit wk = refl
-      lemma-left-unit (weak2 wk)   = refl
-
-      lemma-assoc : ∀ {Γ Δ ∇ Ω} → (wk₃ : Γ ⊇ Δ)(wk₂ : Δ ⊇ ∇)(wk₁ : ∇ ⊇ Ω) →
-        (wk₁ ∘wk wk₂) ∘wk wk₃ ≡ wk₁ ∘wk (wk₂ ∘wk wk₃)
-      lemma-assoc id wk₂ wk₃                 = refl
-      lemma-assoc (weak1 wk₁) wk₂ wk₃
-        rewrite lemma-assoc wk₁ wk₂ wk₃      = refl
-      lemma-assoc (weak2 wk₁) id wk₃         = refl
-      lemma-assoc (weak2 wk₁) (weak1 wk₂) wk₃
-        rewrite lemma-assoc wk₁ wk₂ wk₃      = refl
-      lemma-assoc (weak2 wk₁) (weak2 wk₂) id = refl
-      lemma-assoc (weak2 wk₁) (weak2 wk₂) (weak1 wk₃)
-        rewrite lemma-assoc wk₁ wk₂ wk₃      = refl
-      lemma-assoc (weak2 wk₁) (weak2 wk₂) (weak2 wk₃)
-        rewrite lemma-assoc wk₁ wk₂ wk₃      = refl
+    lemma-assoc : ∀ {Γ Δ ∇ Ω} → (wk₃ : Γ ⊇ Δ)(wk₂ : Δ ⊇ ∇)(wk₁ : ∇ ⊇ Ω) →
+      (wk₁ ∘wk wk₂) ∘wk wk₃ ≡ wk₁ ∘wk (wk₂ ∘wk wk₃)
+    lemma-assoc = {!!}
 
-    open Solution-compose public
 
-.. END HIDE
 
-.. BEGIN HIDE
-
-..
-  ::
-
-    term1 : ε ▹ unit ⊢ unit ⇒ unit
-    term1 = lam (var here)
-
-    term2 : ε ⊢ unit ⇒ unit
-    term2 = lam (var here)
-
-    term3 : ε ▹ unit ⊢ unit ⇒ unit
-    term3 = lam (var (there here))
-
-    term4 : ε ⊢ unit ⇒ unit
-    term4 = lam tt
-
-
-    test1 : sub term1 (λ { here → tt ; (there ()) }) ≡ term2
-    test1 = refl
-
-    test2 : sub term3 (λ { here → tt ; (there ()) }) ≡ term4
-    test2 = refl
-
-.. END HIDE
 
 -------------------------------------
 Normal forms
@@ -1385,21 +1281,6 @@
     remark-reify-fun f = refl
 
 
-.. BEGIN HIDE
-
-..
-  ::
-
-    test-nbe : norm NBE-gensym.Axiom.term₁ ≡ norm NBE-gensym.Axiom.term₂
-    test-nbe = refl
-
-    test-nbe₂ : norm NBE-gensym.Axiom.term₃ ≡ norm NBE-gensym.Axiom.term₄
-    test-nbe₂ = refl
-
-    test-nbe₃ : norm NBE-gensym.Axiom.term₅ ≢ norm NBE-gensym.Axiom.term₆
-    test-nbe₃ = λ ()
-
-.. END HIDE
 
 ************************************************
 Conclusion
